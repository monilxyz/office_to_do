/// <reference types="node" />
import { OAuth2Client, JWT, Compute, UserRefreshClient, BaseExternalAccountClient, GaxiosPromise, GoogleConfigurable, MethodOptions, StreamMethodOptions, GlobalOptions, GoogleAuth, BodyResponseCallback, APIRequestContext } from 'googleapis-common';
import { Readable } from 'stream';
export declare namespace bigquery_v2 {
    export interface Options extends GlobalOptions {
        version: 'v2';
    }
    interface StandardParameters {
        /**
         * Auth client or API Key for the request
         */
        auth?: string | OAuth2Client | JWT | Compute | UserRefreshClient | BaseExternalAccountClient | GoogleAuth;
        /**
         * V1 error format.
         */
        '$.xgafv'?: string;
        /**
         * OAuth access token.
         */
        access_token?: string;
        /**
         * Data format for response.
         */
        alt?: string;
        /**
         * JSONP
         */
        callback?: string;
        /**
         * Selector specifying which fields to include in a partial response.
         */
        fields?: string;
        /**
         * API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
         */
        key?: string;
        /**
         * OAuth 2.0 token for the current user.
         */
        oauth_token?: string;
        /**
         * Returns response with indentations and line breaks.
         */
        prettyPrint?: boolean;
        /**
         * Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
         */
        quotaUser?: string;
        /**
         * Legacy upload protocol for media (e.g. "media", "multipart").
         */
        uploadType?: string;
        /**
         * Upload protocol for media (e.g. "raw", "multipart").
         */
        upload_protocol?: string;
    }
    /**
     * BigQuery API
     *
     * A data platform for customers to create, manage, share and query data.
     *
     * @example
     * ```js
     * const {google} = require('googleapis');
     * const bigquery = google.bigquery('v2');
     * ```
     */
    export class Bigquery {
        context: APIRequestContext;
        datasets: Resource$Datasets;
        jobs: Resource$Jobs;
        models: Resource$Models;
        projects: Resource$Projects;
        routines: Resource$Routines;
        rowAccessPolicies: Resource$Rowaccesspolicies;
        tabledata: Resource$Tabledata;
        tables: Resource$Tables;
        constructor(options: GlobalOptions, google?: GoogleConfigurable);
    }
    /**
     * Aggregate metrics for classification/classifier models. For multi-class models, the metrics are either macro-averaged or micro-averaged. When macro-averaged, the metrics are calculated for each label and then an unweighted average is taken of those values. When micro-averaged, the metric is calculated globally by counting the total number of correctly predicted rows.
     */
    export interface Schema$AggregateClassificationMetrics {
        /**
         * Accuracy is the fraction of predictions given the correct label. For multiclass this is a micro-averaged metric.
         */
        accuracy?: number | null;
        /**
         * The F1 score is an average of recall and precision. For multiclass this is a macro-averaged metric.
         */
        f1Score?: number | null;
        /**
         * Logarithmic Loss. For multiclass this is a macro-averaged metric.
         */
        logLoss?: number | null;
        /**
         * Precision is the fraction of actual positive predictions that had positive actual labels. For multiclass this is a macro-averaged metric treating each class as a binary classifier.
         */
        precision?: number | null;
        /**
         * Recall is the fraction of actual positive labels that were given a positive prediction. For multiclass this is a macro-averaged metric.
         */
        recall?: number | null;
        /**
         * Area Under a ROC Curve. For multiclass this is a macro-averaged metric.
         */
        rocAuc?: number | null;
        /**
         * Threshold at which the metrics are computed. For binary classification models this is the positive class threshold. For multi-class classfication models this is the confidence threshold.
         */
        threshold?: number | null;
    }
    /**
     * Represents privacy policy associated with "aggregation threshold" method.
     */
    export interface Schema$AggregationThresholdPolicy {
        /**
         * Optional. The privacy unit column(s) associated with this policy. For now, only one column per data source object (table, view) is allowed as a privacy unit column. Representing as a repeated field in metadata for extensibility to multiple columns in future. Duplicates and Repeated struct fields are not allowed. For nested fields, use dot notation ("outer.inner")
         */
        privacyUnitColumns?: string[] | null;
        /**
         * Optional. The threshold for the "aggregation threshold" policy.
         */
        threshold?: string | null;
    }
    /**
     * Input/output argument of a function or a stored procedure.
     */
    export interface Schema$Argument {
        /**
         * Optional. Defaults to FIXED_TYPE.
         */
        argumentKind?: string | null;
        /**
         * Required unless argument_kind = ANY_TYPE.
         */
        dataType?: Schema$StandardSqlDataType;
        /**
         * Optional. Whether the argument is an aggregate function parameter. Must be Unset for routine types other than AGGREGATE_FUNCTION. For AGGREGATE_FUNCTION, if set to false, it is equivalent to adding "NOT AGGREGATE" clause in DDL; Otherwise, it is equivalent to omitting "NOT AGGREGATE" clause in DDL.
         */
        isAggregate?: boolean | null;
        /**
         * Optional. Specifies whether the argument is input or output. Can be set for procedures only.
         */
        mode?: string | null;
        /**
         * Optional. The name of this argument. Can be absent for function return argument.
         */
        name?: string | null;
    }
    /**
     * Arima coefficients.
     */
    export interface Schema$ArimaCoefficients {
        /**
         * Auto-regressive coefficients, an array of double.
         */
        autoRegressiveCoefficients?: number[] | null;
        /**
         * Intercept coefficient, just a double not an array.
         */
        interceptCoefficient?: number | null;
        /**
         * Moving-average coefficients, an array of double.
         */
        movingAverageCoefficients?: number[] | null;
    }
    /**
     * ARIMA model fitting metrics.
     */
    export interface Schema$ArimaFittingMetrics {
        /**
         * AIC.
         */
        aic?: number | null;
        /**
         * Log-likelihood.
         */
        logLikelihood?: number | null;
        /**
         * Variance.
         */
        variance?: number | null;
    }
    /**
     * Model evaluation metrics for ARIMA forecasting models.
     */
    export interface Schema$ArimaForecastingMetrics {
        /**
         * Arima model fitting metrics.
         */
        arimaFittingMetrics?: Schema$ArimaFittingMetrics[];
        /**
         * Repeated as there can be many metric sets (one for each model) in auto-arima and the large-scale case.
         */
        arimaSingleModelForecastingMetrics?: Schema$ArimaSingleModelForecastingMetrics[];
        /**
         * Whether Arima model fitted with drift or not. It is always false when d is not 1.
         */
        hasDrift?: boolean[] | null;
        /**
         * Non-seasonal order.
         */
        nonSeasonalOrder?: Schema$ArimaOrder[];
        /**
         * Seasonal periods. Repeated because multiple periods are supported for one time series.
         */
        seasonalPeriods?: string[] | null;
        /**
         * Id to differentiate different time series for the large-scale case.
         */
        timeSeriesId?: string[] | null;
    }
    /**
     * Arima model information.
     */
    export interface Schema$ArimaModelInfo {
        /**
         * Arima coefficients.
         */
        arimaCoefficients?: Schema$ArimaCoefficients;
        /**
         * Arima fitting metrics.
         */
        arimaFittingMetrics?: Schema$ArimaFittingMetrics;
        /**
         * Whether Arima model fitted with drift or not. It is always false when d is not 1.
         */
        hasDrift?: boolean | null;
        /**
         * If true, holiday_effect is a part of time series decomposition result.
         */
        hasHolidayEffect?: boolean | null;
        /**
         * If true, spikes_and_dips is a part of time series decomposition result.
         */
        hasSpikesAndDips?: boolean | null;
        /**
         * If true, step_changes is a part of time series decomposition result.
         */
        hasStepChanges?: boolean | null;
        /**
         * Non-seasonal order.
         */
        nonSeasonalOrder?: Schema$ArimaOrder;
        /**
         * Seasonal periods. Repeated because multiple periods are supported for one time series.
         */
        seasonalPeriods?: string[] | null;
        /**
         * The time_series_id value for this time series. It will be one of the unique values from the time_series_id_column specified during ARIMA model training. Only present when time_series_id_column training option was used.
         */
        timeSeriesId?: string | null;
        /**
         * The tuple of time_series_ids identifying this time series. It will be one of the unique tuples of values present in the time_series_id_columns specified during ARIMA model training. Only present when time_series_id_columns training option was used and the order of values here are same as the order of time_series_id_columns.
         */
        timeSeriesIds?: string[] | null;
    }
    /**
     * Arima order, can be used for both non-seasonal and seasonal parts.
     */
    export interface Schema$ArimaOrder {
        /**
         * Order of the differencing part.
         */
        d?: string | null;
        /**
         * Order of the autoregressive part.
         */
        p?: string | null;
        /**
         * Order of the moving-average part.
         */
        q?: string | null;
    }
    /**
     * (Auto-)arima fitting result. Wrap everything in ArimaResult for easier refactoring if we want to use model-specific iteration results.
     */
    export interface Schema$ArimaResult {
        /**
         * This message is repeated because there are multiple arima models fitted in auto-arima. For non-auto-arima model, its size is one.
         */
        arimaModelInfo?: Schema$ArimaModelInfo[];
        /**
         * Seasonal periods. Repeated because multiple periods are supported for one time series.
         */
        seasonalPeriods?: string[] | null;
    }
    /**
     * Model evaluation metrics for a single ARIMA forecasting model.
     */
    export interface Schema$ArimaSingleModelForecastingMetrics {
        /**
         * Arima fitting metrics.
         */
        arimaFittingMetrics?: Schema$ArimaFittingMetrics;
        /**
         * Is arima model fitted with drift or not. It is always false when d is not 1.
         */
        hasDrift?: boolean | null;
        /**
         * If true, holiday_effect is a part of time series decomposition result.
         */
        hasHolidayEffect?: boolean | null;
        /**
         * If true, spikes_and_dips is a part of time series decomposition result.
         */
        hasSpikesAndDips?: boolean | null;
        /**
         * If true, step_changes is a part of time series decomposition result.
         */
        hasStepChanges?: boolean | null;
        /**
         * Non-seasonal order.
         */
        nonSeasonalOrder?: Schema$ArimaOrder;
        /**
         * Seasonal periods. Repeated because multiple periods are supported for one time series.
         */
        seasonalPeriods?: string[] | null;
        /**
         * The time_series_id value for this time series. It will be one of the unique values from the time_series_id_column specified during ARIMA model training. Only present when time_series_id_column training option was used.
         */
        timeSeriesId?: string | null;
        /**
         * The tuple of time_series_ids identifying this time series. It will be one of the unique tuples of values present in the time_series_id_columns specified during ARIMA model training. Only present when time_series_id_columns training option was used and the order of values here are same as the order of time_series_id_columns.
         */
        timeSeriesIds?: string[] | null;
    }
    /**
     * Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] \}, { "log_type": "DATA_WRITE" \}, { "log_type": "ADMIN_READ" \} ] \}, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" \}, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] \} ] \} ] \} For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
     */
    export interface Schema$AuditConfig {
        /**
         * The configuration for logging of each type of permission.
         */
        auditLogConfigs?: Schema$AuditLogConfig[];
        /**
         * Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
         */
        service?: string | null;
    }
    /**
     * Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] \}, { "log_type": "DATA_WRITE" \} ] \} This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
     */
    export interface Schema$AuditLogConfig {
        /**
         * Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
         */
        exemptedMembers?: string[] | null;
        /**
         * The log type that this config enables.
         */
        logType?: string | null;
    }
    /**
     * Options for external data sources.
     */
    export interface Schema$AvroOptions {
        /**
         * Optional. If sourceFormat is set to "AVRO", indicates whether to interpret logical types as the corresponding BigQuery data type (for example, TIMESTAMP), instead of using the raw type (for example, INTEGER).
         */
        useAvroLogicalTypes?: boolean | null;
    }
    /**
     * Reason why BI Engine didn't accelerate the query (or sub-query).
     */
    export interface Schema$BiEngineReason {
        /**
         * Output only. High-level BI Engine reason for partial or disabled acceleration
         */
        code?: string | null;
        /**
         